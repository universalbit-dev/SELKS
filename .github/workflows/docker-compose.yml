name: Docker Compose CI (Build Dashboard, HTTPS smoke test + Pages)

on:
  push:
  pull_request:
  workflow_dispatch:

permissions:
  contents: read
  pages: write
  id-token: write

jobs:
  build-and-test-and-pages:
    runs-on: ubuntu-latest
    timeout-minutes: 90

    env:
      # Tunables
      COMPOSE_WAIT_SHORT: "120"   # seconds for initial quick waits
      COMPOSE_WAIT_LONG: "600"    # seconds for container health waits
      DB_BIND_DIR: "docker/containers-data/db/data"
      # Candidate UIDs/GIDs to attempt for common DB images (fallback)
      CANDIDATE_UIDS: "1000 999"
      # Name of DB container observed in logs; used for targeted diagnostics/remediation
      DB_CONTAINER_NAME: "docker-db-1"
      # If true, fallback to chmod -R a+rwX when ownership remediation fails (disabled by default)
      DB_RELAX_PERMS: "false"

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Node.js (for frontend build)
        uses: actions/setup-node@v4
        with:
          node-version: "22"

      - name: Install frontend dependencies and build (if package.json exists)
        run: |
          if [[ -f package.json ]]; then
            echo "Found package.json — installing and building"
            npm ci
            if npm run | grep -q "build"; then
              npm run build
            else
              echo "No build script present; ensure dist/ exists or adjust Dockerfile.dashboard"
            fi
          else
            echo "No package.json — skipping frontend build"
          fi

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Ensure docker compose plugin exists
        run: |
          if ! docker compose version >/dev/null 2>&1; then
            sudo apt-get update
            sudo apt-get install -y docker-compose-plugin
          fi
          docker compose version

      - name: Make scripts executable
        run: chmod +x ./scripts/*.sh || true

      - name: Generate self-signed SSL certs for tests
        run: |
          mkdir -p ssl
          if [[ -x ./scripts/generate_ssl.sh ]]; then
            ./scripts/generate_ssl.sh --out-dir ssl --force
          else
            openssl req -nodes -new -x509 -keyout ssl/private-key.pem -out ssl/certificate.pem -days 365 -subj "/CN=localhost"
            chmod 600 ssl/private-key.pem
          fi

      - name: Show compose, build artifacts & SSL debug
        run: |
          echo "=== docker/docker-compose.yml ==="
          sed -n '1,400p' docker/docker-compose.yml || true
          echo "=== dist listing ==="
          ls -la dist || echo "dist not present"
          echo "=== ssl listing ==="
          ls -la ssl || true

      - name: Prepare host volume directories used by bind mounts
        run: |
          set -e
          BASE_DIR="docker/containers-data"
          mkdir -p \
            "$BASE_DIR/suricata/logrotate" \
            "$BASE_DIR/suricata/run" \
            "$BASE_DIR/suricata/rules" \
            "$BASE_DIR/scirius/static" \
            "$BASE_DIR/scirius/data" \
            "$BASE_DIR/arkime/pcap" \
            "$BASE_DIR/db/data" \
            "$BASE_DIR/elastic/data" \
            "$BASE_DIR/logstash/sincedb" || true
          echo "Contents of docker/:"
          ls -la docker || true
          echo "Contents of docker/containers-data/:"
          ls -la docker/containers-data || true

      - name: Detect DB service and image (best-effort)
        id: detect_db
        run: |
          set -euo pipefail
          COMPOSE_FILE="docker/docker-compose.yml"
          DB_SERVICE=""
          # Try to find a service name with db/mysql/postgres/mariadb/database in it
          services=$(awk '/^[[:space:]]*services:/ {in_s=1; next} in_s && /^[[:space:]]*[a-zA-Z0-9_-]+:/ {gsub(/^[[:space:]]*/, ""); print; }' "$COMPOSE_FILE" | sed 's/://g' || true)
          for s in $services; do
            if echo "$s" | grep -Eqi 'db|mysql|postgres|mariadb|database'; then
              DB_SERVICE="$s"
              break
            fi
          done
          # fallback: try exact 'db' service
          if [[ -z "$DB_SERVICE" ]]; then
            if echo "$services" | grep -q '^db$'; then
              DB_SERVICE="db"
            fi
          fi
          # If still empty, pick first service that contains 'mysql' or 'postgres' in its image later
          IMAGE=""
          if [[ -n "$DB_SERVICE" ]]; then
            # Extract image line under the service block
            IMAGE=$(awk -v svc="$DB_SERVICE" '
              BEGIN{found=0}
              /^\s*services\s*:/ {in_services=1; next}
              in_services && $0 ~ "^[[:space:]]+"svc":" {found=1; next}
              found && $0 ~ "^[[:space:]]*[a-zA-Z0-9_-]+:" {exit}
              found && $0 ~ "^[[:space:]]*image:[[:space:]]*" {
                gsub(/^[[:space:]]*image:[[:space:]]*/, ""); print; exit
              }' "$COMPOSE_FILE" || true)
          fi
          # If image empty, attempt to guess by scanning all image: lines for mysql/postgres/mariadb
          if [[ -z "$IMAGE" ]]; then
            IMAGE=$(awk '/image:/ {gsub(/^[[:space:]]*image:[[:space:]]*/, ""); print}' "$COMPOSE_FILE" | grep -E 'mysql|mariadb|postgres' | head -n1 || true)
          fi
          # export results for next steps
          echo "db_service=${DB_SERVICE:-}" >> "$GITHUB_OUTPUT" || true
          echo "db_image=${IMAGE:-}" >> "$GITHUB_OUTPUT" || true
          echo "Detected DB service: ${DB_SERVICE:-<none>}"
          echo "Detected DB image: ${IMAGE:-<none>}"

      - name: Determine DB user UID from image and chown host DB dir (no wide chmod)
        run: |
          set -euo pipefail
          DB_SERVICE="${{ steps.detect_db.outputs.db_service || '' }}"
          DB_IMAGE="${{ steps.detect_db.outputs.db_image || '' }}"
          HOST_DB_DIR="$GITHUB_WORKSPACE/${DB_BIND_DIR}"
          mkdir -p "$HOST_DB_DIR" || true
          echo "Host DB dir: $HOST_DB_DIR"
          echo "Detected DB service: '$DB_SERVICE'; detected DB image: '$DB_IMAGE'"
          resolved_uid=""
          resolved_gid=""
          if [[ -n "$DB_IMAGE" ]]; then
            echo "Attempting to detect DB user uid/gid by running a temporary container from image: $DB_IMAGE"
            # Try to run id commands inside a lightweight shell; some images may not have 'id' or 'sh'.
            # We'll try common user names first (postgres, mysql, mariadb) and fallback to 'id -u' if available.
            for user in postgres mysql mariadb; do
              echo "Trying id for user '$user'..."
              out=$(docker run --rm --entrypoint sh --workdir / -v /etc/passwd:/etc/passwd:ro "$DB_IMAGE" -c "id -u $user 2>/dev/null || true") || out=""
              if [[ -n "$out" && "$out" =~ ^[0-9]+$ ]]; then
                resolved_uid="$out"
                # try gid
                g=$(docker run --rm --entrypoint sh --workdir / "$DB_IMAGE" -c "id -g $user 2>/dev/null || true") || g=""
                if [[ -n "$g" && "$g" =~ ^[0-9]+$ ]]; then
                  resolved_gid="$g"
                fi
                echo "Found UID for user $user: $resolved_uid (GID: ${resolved_gid:-<none>})"
                break
              fi
            done

            if [[ -z "$resolved_uid" ]]; then
              # Try retrieving UID for the default user (id -u)
              echo "Trying to run 'id -u' in container to get default user uid..."
              out=$(docker run --rm --entrypoint sh --workdir / "$DB_IMAGE" -c "id -u 2>/dev/null || true") || out=""
              if [[ -n "$out" && "$out" =~ ^[0-9]+$ ]]; then
                resolved_uid="$out"
                g=$(docker run --rm --entrypoint sh --workdir / "$DB_IMAGE" -c "id -g 2>/dev/null || true") || g=""
                if [[ -n "$g" && "$g" =~ ^[0-9]+$ ]]; then
                  resolved_gid="$g"
                fi
                echo "Found default UID: $resolved_uid (GID: ${resolved_gid:-<none>})"
              fi
            fi
          fi

          # If still not found, try candidate UIDs
          if [[ -z "$resolved_uid" ]]; then
            echo "Could not detect UID from image. Trying fallback candidate UIDs: $CANDIDATE_UIDS"
            for uid in $CANDIDATE_UIDS; do
              echo "Attempting chown to ${uid}:${uid} for $HOST_DB_DIR (best-effort)..."
              sudo chown -R "${uid}:${uid}" "$HOST_DB_DIR" && resolved_uid="$uid" && resolved_gid="$uid" && break || true
            done
          fi

          if [[ -n "$resolved_uid" ]]; then
            echo "Applying ownership ${resolved_uid}:${resolved_gid:-$resolved_uid} to $HOST_DB_DIR"
            sudo chown -R "${resolved_uid}:${resolved_gid:-$resolved_uid}" "$HOST_DB_DIR" || true
            echo "Ownership now:"
            ls -ld "$HOST_DB_DIR" || true
            ls -la "$(dirname "$HOST_DB_DIR")" || true
          else
            echo "WARNING: Could not determine a UID to chown to. Will NOT relax permissions unless DB_RELAX_PERMS=true"
            if [[ "${DB_RELAX_PERMS}" == "true" ]]; then
              echo "DB_RELAX_PERMS=true: relaxing permissions as last resort"
              sudo chmod -R a+rwX "$HOST_DB_DIR" || true
            fi
            ls -ld "$HOST_DB_DIR" || true
          fi

      - name: Start docker-compose stack (build & up)
        working-directory: docker
        env:
          COMPOSE_HTTP_TIMEOUT: 600
        run: |
          docker compose up -d --build

      - name: Quick wait for services to appear
        working-directory: docker
        run: |
          for i in $(seq 1 40); do
            echo "Initial compose ps ($i)"
            docker compose ps || true
            sleep 2
          done

      - name: Wait for containers' health (wait & debug + DB remediation)
        working-directory: docker
        run: |
          set -euo pipefail
          echo "Listing containers:"
          docker ps --format 'table {{.Names}}\t{{.Image}}\t{{.Status}}' || true

          TIMEOUT_SECS=${COMPOSE_WAIT_LONG}
          SLEEP_INTERVAL=5
          MAX_TRIES=$((TIMEOUT_SECS / SLEEP_INTERVAL))

          CONTAINERS=$(docker compose ps --services --quiet 2>/dev/null || true)
          if [[ -n "$CONTAINERS" ]]; then
            NAMES=""
            for svc in $CONTAINERS; do
              CN=$(docker ps --filter "label=com.docker.compose.service=$svc" --format '{{.Names}}' | head -n1 || true)
              if [[ -n "$CN" ]]; then
                NAMES="$NAMES $CN"
              fi
            done
            CONTAINERS="$NAMES"
          else
            CONTAINERS=$(docker ps --format '{{.Names}}' | grep -E 'docker-' || true)
          fi

          if [[ -z "$CONTAINERS" ]]; then
            echo "No containers found by heuristics; printing docker compose ps and failing."
            docker compose ps || true
            exit 1
          fi

          echo "Containers to check:"
          echo "$CONTAINERS"

          FAILED=0
          for C in $CONTAINERS; do
            echo "Waiting for container '$C' to become healthy (if it has a healthcheck). Timeout ${TIMEOUT_SECS}s..."
            STATUS=""
            for try in $(seq 1 $MAX_TRIES); do
              HEALTH_JSON=$(docker inspect --format='{{json .State.Health}}' "$C" 2>/dev/null || echo "")
              if [[ -z "$HEALTH_JSON" ]]; then
                STATE=$(docker inspect --format='{{.State.Status}}' "$C" 2>/dev/null || echo "not_found")
                echo "  No Health object for $C; State.Status=$STATE"
                if [[ "$STATE" == "running" ]]; then
                  echo "  $C is running and has no healthcheck -> treating as OK"
                  STATUS="nohealth"
                  break
                fi
              else
                HEALTH_STATUS=$(docker inspect --format='{{.State.Health.Status}}' "$C" 2>/dev/null || echo "")
                echo "  Health status: $HEALTH_STATUS"
                if [[ "$HEALTH_STATUS" == "healthy" ]]; then
                  STATUS="healthy"
                  break
                fi
                if [[ "$HEALTH_STATUS" == "unhealthy" ]]; then
                  STATUS="unhealthy"
                fi
              fi
              sleep $SLEEP_INTERVAL
            done

            if [[ "$STATUS" == "healthy" || "$STATUS" == "nohealth" ]]; then
              echo "Container $C OK (status=$STATUS)"
            else
              echo "Container $C failed to become healthy (status=${STATUS:-unknown})"
              echo "=== docker inspect $C ==="
              docker inspect "$C" || true
              echo "=== docker logs $C (last 1000 lines) ==="
              docker logs --tail 1000 "$C" || true

              if [[ "$C" == "${DB_CONTAINER_NAME}" || "$C" =~ db ]]; then
                echo "Detected DB container ($C) failing; showing host bind mount dir info for $DB_BIND_DIR"
                ls -ld "$GITHUB_WORKSPACE/$DB_BIND_DIR" || true
                ls -la "$GITHUB_WORKSPACE/$DB_BIND_DIR" || true
                echo "Attempting remediation: determine UID from image and chown host dir, then recreate DB service"

                # try determine image again
                DB_IMAGE="${{ steps.detect_db.outputs.db_image || '' }}"
                if [[ -n "$DB_IMAGE" ]]; then
                  echo "DB image (remediation): $DB_IMAGE"
                  # attempt to detect uid again
                  uid=$(docker run --rm --entrypoint sh "$DB_IMAGE" -c "id -u postgres 2>/dev/null || id -u mysql 2>/dev/null || id -u 2>/dev/null || true" || true)
                  if [[ -n "$uid" && "$uid" =~ ^[0-9]+$ ]]; then
                    echo "Remediation found uid: $uid"
                    sudo chown -R "${uid}:${uid}" "$GITHUB_WORKSPACE/$DB_BIND_DIR" || true
                  else
                    echo "Remediation could not detect uid; trying candidate uids"
                    for u in $CANDIDATE_UIDS; do
                      sudo chown -R "${u}:${u}" "$GITHUB_WORKSPACE/$DB_BIND_DIR" || true
                    done
                    if [[ "${DB_RELAX_PERMS}" == "true" ]]; then
                      echo "DB_RELAX_PERMS=true: relaxing permissions as last resort"
                      sudo chmod -R a+rwX "$GITHUB_WORKSPACE/$DB_BIND_DIR" || true
                    fi
                  fi
                fi

                echo "Recreating DB service with docker compose (no-deps, force recreate)"
                docker compose up -d --no-deps --force-recreate db || docker compose up -d --no-deps --force-recreate || true
                sleep 15
                echo "DB logs after remediation:"
                docker logs --tail 1000 "$C" || true
              fi

              FAILED=1
            fi
          done

          if [[ $FAILED -ne 0 ]]; then
            echo "One or more containers failed health checks. Saving compose logs for debugging."
            docker compose logs --no-color > compose_logs.txt || true
            docker logs --tail 2000 "${DB_CONTAINER_NAME}" > docker-db-1.logs 2>&1 || true
            exit 1
          fi

      - name: HTTPS smoke test (curl -k)
        id: smoke
        working-directory: docker
        run: |
          set -e
          RESULT=1
          for i in {1..40}; do
            if curl -k --silent --show-error --fail https://localhost:443/ -I; then
              echo "ok" > ./smoke_result.txt
              RESULT=0
              break
            fi
            echo "Waiting for HTTPS... ($i)"
            sleep 3
          done
          if [[ $RESULT -ne 0 ]]; then
            echo "fail" > ./smoke_result.txt
            docker compose logs --no-color > compose_logs.txt || true
            exit 1
          fi

      - name: Snapshot dashboard HTML (for Pages visualization)
        working-directory: docker
        run: |
          mkdir -p ../pages-site
          if curl -k --max-time 10 --silent --show-error https://localhost:443/ -o ../pages-site/dashboard_snapshot.html; then
            echo "Saved dashboard snapshot to pages-site/dashboard_snapshot.html"
          else
            echo "<!-- snapshot failed -->" > ../pages-site/dashboard_snapshot.html || true
          fi

      - name: Collect logs & create pages site
        working-directory: docker
        run: |
          PAGES_DIR=../pages-site
          mkdir -p "$PAGES_DIR"
          STATUS=$(cat ./smoke_result.txt || echo "unknown")
          RUN_URL="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          LOG_SNIPPET="$(tail -n 200 compose_logs.txt 2>/dev/null || echo "No logs available")"
          printf '%s\n' \
            '<!doctype html>' \
            '<html>' \
            '  <head><meta charset="utf-8"><title>SELKS Docker Compose smoke test</title></head>' \
            '  <body>' \
            '    <h1>SELKS Docker Compose smoke test</h1>' \
            "    <p>Result: <strong>${STATUS}</strong></p>" \
            "    <p>Workflow run: <a href=\"${RUN_URL}\">Open run</a></p>" \
            '    <h2>Dashboard snapshot</h2>' \
            '    <p>If snapshot failed, the file may be empty or contain an error note.</p>' \
            '    <iframe src="dashboard_snapshot.html" style="width:100%;height:600px;border:1px solid #ccc;"></iframe>' \
            '    <h2>Compose logs (tail)</h2>' \
            '    <pre>' > "$PAGES_DIR/index.html"
          printf '%s\n' "$(printf '%s' "${LOG_SNIPPET}" | sed -e 's/&/\&amp;/g' -e 's/</\&lt;/g' -e 's/>/\&gt;/g')" >> "$PAGES_DIR/index.html"
          printf '%s\n' \
            '</pre>' \
            '    <p>Full logs: <a href="compose_logs.txt">compose_logs.txt</a></p>' \
            '  </body>' \
            '</html>' >> "$PAGES_DIR/index.html"
          cp compose_logs.txt "$PAGES_DIR/compose_logs.txt" || true
          cp docker-db-1.logs "$PAGES_DIR/docker-db-1.logs" || true
          ls -la "$PAGES_DIR"

      - name: Upload Pages artifact
        uses: actions/upload-pages-artifact@v3
        with:
          path: pages-site

      - name: Deploy to GitHub Pages
        uses: actions/deploy-pages@v2

      - name: Upload debug artifacts on failure
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: docker-compose-debug
          path: |
            compose_logs.txt
            docker-db-1.logs

      - name: Tear down compose stack
        if: always()
        working-directory: docker
        run: |
          docker compose down --volumes --remove-orphans || true
