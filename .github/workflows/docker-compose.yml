name: Docker Compose CI (Build Dashboard, HTTPS smoke test + Pages)

on:
  push:
  pull_request:
  workflow_dispatch:

permissions:
  contents: read
  pages: write
  id-token: write

jobs:
  build-and-test-and-pages:
    runs-on: ubuntu-latest
    timeout-minutes: 90

    env:
      COMPOSE_WAIT_LONG: "600"
      DB_BIND_DIR: "docker/containers-data/db/data"
      CANDIDATE_UIDS: "1000 999"
      DB_CONTAINER_NAME: "docker-db-1"
      DB_RELAX_PERMS: "false"

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Node.js (for frontend build)
        uses: actions/setup-node@v4
        with:
          node-version: "22"

      - name: Install frontend dependencies and build (if package.json exists)
        run: |
          if [[ -f package.json ]]; then
            npm ci
            if npm run | grep -q "build"; then
              npm run build
            fi
          fi

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Ensure docker compose plugin exists
        run: |
          if ! docker compose version >/dev/null 2>&1; then
            sudo apt-get update
            sudo apt-get install -y docker-compose-plugin
          fi
          docker compose version

      - name: Make scripts executable
        run: chmod +x ./scripts/*.sh || true

      - name: Generate self-signed SSL certs for tests
        run: |
          mkdir -p ssl
          if [[ -x ./scripts/generate_ssl.sh ]]; then
            ./scripts/generate_ssl.sh --out-dir ssl --force
          else
            openssl req -nodes -new -x509 -keyout ssl/private-key.pem -out ssl/certificate.pem -days 365 -subj "/CN=localhost"
            chmod 600 ssl/private-key.pem
          fi

      - name: Show compose, build artifacts & SSL debug
        run: |
          echo "=== docker/docker-compose.yml ==="
          sed -n '1,400p' docker/docker-compose.yml || true
          echo "=== dist listing ==="
          ls -la dist || echo "dist not present"
          echo "=== ssl listing ==="
          ls -la ssl || true

      - name: Prepare host volume directories used by bind mounts
        run: |
          set -e
          BASE_DIR="docker/containers-data"
          mkdir -p \
            "$BASE_DIR/suricata/logrotate" \
            "$BASE_DIR/suricata/run" \
            "$BASE_DIR/suricata/rules" \
            "$BASE_DIR/scirius/static" \
            "$BASE_DIR/scirius/data" \
            "$BASE_DIR/arkime/pcap" \
            "$BASE_DIR/db/data" \
            "$BASE_DIR/elastic/data" \
            "$BASE_DIR/logstash/sincedb" || true
          ls -la docker || true
          ls -la docker/containers-data || true

      - name: Detect DB service and image (best-effort)
        id: detect_db
        run: |
          set -euo pipefail
          COMPOSE_FILE="docker/docker-compose.yml"
          DB_SERVICE=""
          services=$(awk '/^[[:space:]]*services:/ {in_s=1; next} in_s && /^[[:space:]]*[a-zA-Z0-9_-]+:/ {gsub(/^[[:space:]]*/, ""); print; }' "$COMPOSE_FILE" | sed 's/://g' || true)
          for s in $services; do
            if echo "$s" | grep -Eqi 'db|mysql|postgres|mariadb|database'; then
              DB_SERVICE="$s"
              break
            fi
          done
          if [[ -z "$DB_SERVICE" ]]; then
            if echo "$services" | grep -q '^db$'; then
              DB_SERVICE="db"
            fi
          fi
          IMAGE=""
          if [[ -n "$DB_SERVICE" ]]; then
            IMAGE=$(awk -v svc="$DB_SERVICE" '
              BEGIN{found=0}
              /^\s*services\s*:/ {in_services=1; next}
              in_services && $0 ~ "^[[:space:]]+"svc":" {found=1; next}
              found && $0 ~ "^[[:space:]]*[a-zA-Z0-9_-]+:" {exit}
              found && $0 ~ "^[[:space:]]*image:[[:space:]]*" {
                gsub(/^[[:space:]]*image:[[:space:]]*/, ""); print; exit
              }' "$COMPOSE_FILE" || true)
          fi
          if [[ -z "$IMAGE" ]]; then
            IMAGE=$(awk '/image:/ {gsub(/^[[:space:]]*image:[[:space:]]*/, ""); print}' "$COMPOSE_FILE" | grep -E 'mysql|mariadb|postgres' | head -n1 || true)
          fi
          echo "db_service=${DB_SERVICE:-}" >> "$GITHUB_OUTPUT" || true
          echo "db_image=${IMAGE:-}" >> "$GITHUB_OUTPUT" || true
          echo "Detected DB service: ${DB_SERVICE:-<none>}"
          echo "Detected DB image: ${IMAGE:-<none>}"

      - name: Determine DB user UID from image and chown host DB dir (no wide chmod by default)
        run: |
          set -euo pipefail
          DB_IMAGE="${{ steps.detect_db.outputs.db_image || '' }}"
          HOST_DB_DIR="$GITHUB_WORKSPACE/${DB_BIND_DIR}"
          mkdir -p "$HOST_DB_DIR" || true
          resolved_uid=""
          resolved_gid=""
          if [[ -n "$DB_IMAGE" ]]; then
            for user in postgres mysql mariadb; do
              out=$(docker run --rm --entrypoint sh --workdir / -v /etc/passwd:/etc/passwd:ro "$DB_IMAGE" -c "id -u $user 2>/dev/null || true") || out=""
              if [[ -n "$out" && "$out" =~ ^[0-9]+$ ]]; then
                resolved_uid="$out"
                g=$(docker run --rm --entrypoint sh --workdir / "$DB_IMAGE" -c "id -g $user 2>/dev/null || true") || g=""
                if [[ -n "$g" && "$g" =~ ^[0-9]+$ ]]; then
                  resolved_gid="$g"
                fi
                break
              fi
            done
            if [[ -z "$resolved_uid" ]]; then
              out=$(docker run --rm --entrypoint sh --workdir / "$DB_IMAGE" -c "id -u 2>/dev/null || true") || out=""
              if [[ -n "$out" && "$out" =~ ^[0-9]+$ ]]; then
                resolved_uid="$out"
                g=$(docker run --rm --entrypoint sh --workdir / "$DB_IMAGE" -c "id -g 2>/dev/null || true") || g=""
                if [[ -n "$g" && "$g" =~ ^[0-9]+$ ]]; then
                  resolved_gid="$g"
                fi
              fi
            fi
          fi
          if [[ -z "$resolved_uid" ]]; then
            for uid in $CANDIDATE_UIDS; do
              sudo chown -R "${uid}:${uid}" "$HOST_DB_DIR" && resolved_uid="$uid" && resolved_gid="$uid" && break || true
            done
          fi
          if [[ -n "$resolved_uid" ]]; then
            sudo chown -R "${resolved_uid}:${resolved_gid:-$resolved_uid}" "$HOST_DB_DIR" || true
            ls -ld "$HOST_DB_DIR" || true
          else
            echo "Could not determine UID to chown to. Will NOT relax permissions unless DB_RELAX_PERMS=true"
            if [[ "${DB_RELAX_PERMS}" == "true" ]]; then
              sudo chmod -R a+rwX "$HOST_DB_DIR" || true
            fi
            ls -ld "$HOST_DB_DIR" || true
          fi

      - name: Start docker-compose stack (build & up)
        working-directory: docker
        env:
          COMPOSE_HTTP_TIMEOUT: 600
        run: |
          docker compose up -d --build

      - name: DB readiness probe (Postgres / MySQL)
        working-directory: docker
        run: |
          set -euo pipefail
          DB_IMAGE="${{ steps.detect_db.outputs.db_image || '' }}"
          DB_CONTAINER="${DB_CONTAINER_NAME}"
          echo "DB image detected: $DB_IMAGE; DB container target: $DB_CONTAINER"
          # Wait until container exists
          for i in {1..30}; do
            if docker ps --format '{{.Names}}' | grep -q "^${DB_CONTAINER}$"; then
              echo "DB container $DB_CONTAINER is present"
              break
            fi
            echo "Waiting for DB container to appear... ($i)"
            sleep 2
          done
          # Engine-specific checks
          PROBE_OK=1
          if [[ "$DB_IMAGE" == *postgres* || "$DB_IMAGE" == *postgresql* ]]; then
            echo "Running pg_isready probe (exec into container)..."
            for i in $(seq 1 60); do
              if docker exec "$DB_CONTAINER" sh -c "pg_isready -q" >/dev/null 2>&1; then
                echo "pg_isready: OK"
                PROBE_OK=0
                break
              fi
              echo "pg_isready not ready yet ($i)"
              sleep 5
            done
          elif [[ "$DB_IMAGE" == *mysql* || "$DB_IMAGE" == *mariadb* ]]; then
            echo "Running mysqladmin ping probe (exec into container)..."
            for i in $(seq 1 60); do
              if docker exec "$DB_CONTAINER" sh -c "mysqladmin ping --silent" >/dev/null 2>&1; then
                echo "mysqladmin ping: OK"
                PROBE_OK=0
                break
              fi
              echo "mysqladmin not ready yet ($i)"
              sleep 5
            done
          else
            echo "DB image not detected or unsupported for engine probe; skipping engine probe"
            PROBE_OK=0
          fi
          if [[ $PROBE_OK -ne 0 ]]; then
            echo "DB readiness probe failed. Collecting logs and inspect for debugging."
            docker inspect "$DB_CONTAINER" || true
            docker logs --tail 1000 "$DB_CONTAINER" || true
            # save logs to workspace root so artifact step finds them
            docker compose logs --no-color > "$GITHUB_WORKSPACE/compose_logs.txt" || true
            docker logs --tail 2000 "$DB_CONTAINER" > "$GITHUB_WORKSPACE/docker-db-1.logs" 2>&1 || true
            exit 1
          fi

      - name: Quick wait for services to appear
        working-directory: docker
        run: |
          for i in $(seq 1 20); do
            docker compose ps || true
            sleep 2
          done

      - name: Wait for containers' health (wait & debug + DB remediation)
        working-directory: docker
        run: |
          set -euo pipefail
          TIMEOUT_SECS=${COMPOSE_WAIT_LONG}
          SLEEP_INTERVAL=5
          MAX_TRIES=$((TIMEOUT_SECS / SLEEP_INTERVAL))

          CONTAINERS=$(docker compose ps --services --quiet 2>/dev/null || true)
          if [[ -n "$CONTAINERS" ]]; then
            NAMES=""
            for svc in $CONTAINERS; do
              CN=$(docker ps --filter "label=com.docker.compose.service=$svc" --format '{{.Names}}' | head -n1 || true)
              if [[ -n "$CN" ]]; then
                NAMES="$NAMES $CN"
              fi
            done
            CONTAINERS="$NAMES"
          else
            CONTAINERS=$(docker ps --format '{{.Names}}' | grep -E 'docker-' || true)
          fi

          if [[ -z "$CONTAINERS" ]]; then
            docker compose ps || true
            exit 1
          fi

          FAILED=0
          for C in $CONTAINERS; do
            STATUS=""
            for try in $(seq 1 $MAX_TRIES); do
              HEALTH_JSON=$(docker inspect --format='{{json .State.Health}}' "$C" 2>/dev/null || echo "")
              if [[ -z "$HEALTH_JSON" ]]; then
                STATE=$(docker inspect --format='{{.State.Status}}' "$C" 2>/dev/null || echo "not_found")
                if [[ "$STATE" == "running" ]]; then
                  STATUS="nohealth"
                  break
                fi
              else
                HEALTH_STATUS=$(docker inspect --format='{{.State.Health.Status}}' "$C" 2>/dev/null || echo "")
                if [[ "$HEALTH_STATUS" == "healthy" ]]; then
                  STATUS="healthy"
                  break
                fi
                if [[ "$HEALTH_STATUS" == "unhealthy" ]]; then
                  STATUS="unhealthy"
                fi
              fi
              sleep $SLEEP_INTERVAL
            done

            if [[ "$STATUS" == "healthy" || "$STATUS" == "nohealth" ]]; then
              echo "Container $C OK (status=$STATUS)"
            else
              echo "Container $C failed to become healthy (status=${STATUS:-unknown})"
              docker inspect "$C" || true
              docker logs --tail 1000 "$C" || true

              if [[ "$C" == "${DB_CONTAINER_NAME}" || "$C" =~ db ]]; then
                ls -ld "$GITHUB_WORKSPACE/$DB_BIND_DIR" || true
                ls -la "$GITHUB_WORKSPACE/$DB_BIND_DIR" || true
                DB_IMAGE="${{ steps.detect_db.outputs.db_image || '' }}"
                if [[ -n "$DB_IMAGE" ]]; then
                  uid=$(docker run --rm --entrypoint sh "$DB_IMAGE" -c "id -u postgres 2>/dev/null || id -u mysql 2>/dev/null || id -u 2>/dev/null || true" || true)
                  if [[ -n "$uid" && "$uid" =~ ^[0-9]+$ ]]; then
                    sudo chown -R "${uid}:${uid}" "$GITHUB_WORKSPACE/$DB_BIND_DIR" || true
                  else
                    for u in $CANDIDATE_UIDS; do
                      sudo chown -R "${u}:${u}" "$GITHUB_WORKSPACE/$DB_BIND_DIR" || true
                    done
                    if [[ "${DB_RELAX_PERMS}" == "true" ]]; then
                      sudo chmod -R a+rwX "$GITHUB_WORKSPACE/$DB_BIND_DIR" || true
                    fi
                  fi
                fi
                docker compose up -d --no-deps --force-recreate db || docker compose up -d --no-deps --force-recreate || true
                sleep 15
                docker logs --tail 1000 "$C" || true
              fi

              FAILED=1
            fi
          done

          if [[ $FAILED -ne 0 ]]; then
            docker compose logs --no-color > "$GITHUB_WORKSPACE/compose_logs.txt" || true
            docker logs --tail 2000 "${DB_CONTAINER_NAME}" > "$GITHUB_WORKSPACE/docker-db-1.logs" 2>&1 || true
            exit 1
          fi

      - name: HTTPS smoke test (curl -k)
        id: smoke
        working-directory: docker
        run: |
          set -e
          RESULT=1
          for i in {1..40}; do
            if curl -k --silent --show-error --fail https://localhost:443/ -I; then
              echo "ok" > ./smoke_result.txt
              RESULT=0
              break
            fi
            sleep 3
          done
          if [[ $RESULT -ne 0 ]]; then
            docker compose logs --no-color > "$GITHUB_WORKSPACE/compose_logs.txt" || true
            exit 1
          fi

      - name: Snapshot dashboard HTML (for Pages visualization)
        working-directory: docker
        run: |
          mkdir -p ../pages-site
          if curl -k --max-time 10 --silent --show-error https://localhost:443/ -o ../pages-site/dashboard_snapshot.html; then
            echo "Saved dashboard snapshot to pages-site/dashboard_snapshot.html"
          else
            echo "<!-- snapshot failed -->" > ../pages-site/dashboard_snapshot.html || true

      - name: Collect logs & create pages site
        working-directory: docker
        run: |
          PAGES_DIR=../pages-site
          mkdir -p "$PAGES_DIR"
          STATUS=$(cat ./smoke_result.txt || echo "unknown")
          RUN_URL="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          LOG_SNIPPET="$(tail -n 200 "$GITHUB_WORKSPACE/compose_logs.txt" 2>/dev/null || echo "No logs available")"
          printf '%s\n' \
            '<!doctype html>' \
            '<html>' \
            '  <head><meta charset="utf-8"><title>SELKS Docker Compose smoke test</title></head>' \
            '  <body>' \
            '    <h1>SELKS Docker Compose smoke test</h1>' \
            "    <p>Result: <strong>${STATUS}</strong></p>" \
            "    <p>Workflow run: <a href=\"${RUN_URL}\">Open run</a></p>" \
            '    <h2>Dashboard snapshot</h2>' \
            '    <iframe src="dashboard_snapshot.html" style="width:100%;height:600px;border:1px solid #ccc;"></iframe>' \
            '    <h2>Compose logs (tail)</h2>' \
            '    <pre>' > "$PAGES_DIR/index.html"
          printf '%s\n' "$(printf '%s' "${LOG_SNIPPET}" | sed -e 's/&/\&amp;/g' -e 's/</\&lt;/g' -e 's/>/\&gt;/g')" >> "$PAGES_DIR/index.html"
          printf '%s\n' \
            '</pre>' \
            '    <p>Full logs: <a href="compose_logs.txt">compose_logs.txt</a></p>' \
            '  </body>' \
            '</html>' >> "$PAGES_DIR/index.html"
          cp "$GITHUB_WORKSPACE/compose_logs.txt" "$PAGES_DIR/compose_logs.txt" || true
          cp "$GITHUB_WORKSPACE/docker-db-1.logs" "$PAGES_DIR/docker-db-1.logs" || true
          ls -la "$PAGES_DIR"

      - name: Upload Pages artifact
        uses: actions/upload-pages-artifact@v3
        with:
          path: pages-site

      - name: Deploy to GitHub Pages
        uses: actions/deploy-pages@v2

      - name: Upload debug artifacts on failure
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: docker-compose-debug
          path: |
            compose_logs.txt
            docker-db-1.logs

      - name: Tear down compose stack
        if: always()
        working-directory: docker
        run: |
          docker compose down --volumes --remove-orphans || true
