name: Docker Compose CI (Build Dashboard, HTTPS smoke test + Pages)

on:
  push:
  pull_request:
  workflow_dispatch:

permissions:
  contents: read
  pages: write
  id-token: write

jobs:
  build-and-test-and-pages:
    runs-on: ubuntu-latest
    timeout-minutes: 60

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Node.js (for frontend build)
        uses: actions/setup-node@v4
        with:
          node-version: "22"

      - name: Install frontend dependencies and build (if package.json exists)
        run: |
          if [[ -f package.json ]]; then
            echo "Found package.json — installing and building"
            npm ci
            if npm run | grep -q "build"; then
              npm run build
            else
              echo "No build script present; ensure dist/ exists or adjust Dockerfile.dashboard"
            fi
          else
            echo "No package.json — skipping frontend build"
          fi

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Ensure docker compose plugin exists
        run: |
          if ! docker compose version >/dev/null 2>&1; then
            sudo apt-get update
            sudo apt-get install -y docker-compose-plugin
          fi
          docker compose version

      - name: Make scripts executable
        run: chmod +x ./scripts/*.sh || true

      - name: Generate self-signed SSL certs for tests
        run: |
          mkdir -p ssl
          if [[ -x ./scripts/generate_ssl.sh ]]; then
            ./scripts/generate_ssl.sh --out-dir ssl --force
          else
            openssl req -nodes -new -x509 -keyout ssl/private-key.pem -out ssl/certificate.pem -days 365 -subj "/CN=localhost"
            chmod 600 ssl/private-key.pem
          fi

      - name: Show compose, build artifacts & SSL debug
        run: |
          echo "=== docker/docker-compose.yml ==="
          sed -n '1,300p' docker/docker-compose.yml || true
          echo "=== dist listing ==="
          ls -la dist || echo "dist not present"
          echo "=== ssl listing ==="
          ls -la ssl || true

      - name: Prepare host volume directories used by bind mounts
        # Create any host directories docker-compose expects under docker/containers-data
        run: |
          set -e
          BASE_DIR="docker/containers-data"
          mkdir -p \
            "$BASE_DIR/suricata/logrotate" \
            "$BASE_DIR/suricata/run" \
            "$BASE_DIR/suricata/rules" \
            "$BASE_DIR/scirius/static" \
            "$BASE_DIR/scirius/data" \
            "$BASE_DIR/arkime/pcap" \
            "$BASE_DIR/db/data" \
            "$BASE_DIR/elastic/data" \
            "$BASE_DIR/logstash/sincedb" || true
          # Show what we created so logs help debugging
          ls -la docker || true
          ls -la "$BASE_DIR" || true

      - name: Start docker-compose stack (build & up)
        working-directory: docker
        env:
          COMPOSE_HTTP_TIMEOUT: 300
        run: |
          docker compose up -d --build

      - name: Wait for services to appear (quick loop)
        working-directory: docker
        run: |
          for i in {1..40}; do
            docker compose ps || true
            sleep 2
          done

      - name: Wait for containers' health (wait & debug)
        working-directory: docker
        run: |
          set -euo pipefail
          # Adjust these names if your compose project name differs. The logs showed container names like 'docker-db-1'.
          # We attempt to detect containers created by compose in this project and wait for their health status.
          echo "Listing containers:"
          docker ps --format 'table {{.Names}}\t{{.Image}}\t{{.Status}}' || true
          # Configure timeout (seconds) to wait per container
          TIMEOUT_SECS=240
          SLEEP_INTERVAL=3
          MAX_TRIES=$((TIMEOUT_SECS / SLEEP_INTERVAL))

          # Build list of containers started by the compose project (filter by network prefix docker_ if present)
          # Fallback: use compose ps --services to map to container names
          CONTAINERS=$(docker ps --filter "network=docker_default" --format '{{.Names}}' || true)
          if [[ -z "$CONTAINERS" ]]; then
            # Fallback: list all containers whose name contains 'docker-' prefix (common for compose project named docker)
            CONTAINERS=$(docker ps --format '{{.Names}}' | grep -E 'docker-' || true)
          fi

          if [[ -z "$CONTAINERS" ]]; then
            echo "No containers found by heuristics; printing docker compose ps and failing."
            docker compose ps || true
            exit 1
          fi

          echo "Containers to check:"
          echo "$CONTAINERS"

          FAILED=0
          for C in $CONTAINERS; do
            echo "Waiting for container '$C' to become healthy (if it has a healthcheck). Timeout ${TIMEOUT_SECS}s..."
            STATUS=""
            for try in $(seq 1 $MAX_TRIES); do
              # If inspect fails, container may not be up yet; continue
              STATUS=$(docker inspect --format='{{json .State.Health}}' "$C" 2>/dev/null || echo "")
              if [[ -z "$STATUS" ]]; then
                # No health object; examine .State.Status to see if running
                STATE=$(docker inspect --format='{{.State.Status}}' "$C" 2>/dev/null || echo "not_found")
                echo "  No Health object for $C; State.Status=$STATE"
                # If container is running, treat it as OK (no healthcheck)
                if [[ "$STATE" == "running" ]]; then
                  echo "  $C is running and has no healthcheck -> skipping health waits"
                  STATUS="nohealth"
                  break
                fi
              else
                # parse Health.Status value by inspecting the Health JSON
                HEALTH_STATUS=$(docker inspect --format='{{.State.Health.Status}}' "$C" 2>/dev/null || echo "")
                echo "  Health status: $HEALTH_STATUS"
                if [[ "$HEALTH_STATUS" == "healthy" ]]; then
                  STATUS="healthy"
                  break
                fi
                if [[ "$HEALTH_STATUS" == "unhealthy" ]]; then
                  STATUS="unhealthy"
                  # continue to allow retries in case it recovers
                fi
              fi
              sleep $SLEEP_INTERVAL
            done

            if [[ "$STATUS" == "healthy" || "$STATUS" == "nohealth" ]]; then
              echo "Container $C OK (status=$STATUS)"
            else
              echo "Container $C failed to become healthy (status=${STATUS:-unknown})"
              echo "=== docker inspect $C ==="
              docker inspect "$C" || true
              echo "=== docker logs $C (last 500 lines) ==="
              docker logs --tail 500 "$C" || true
              FAILED=1
            fi
          done

          if [[ $FAILED -ne 0 ]]; then
            echo "One or more containers failed health checks. See logs above."
            # Optional: save compose logs for upload (compose_logs.txt)
            docker compose logs --no-color > compose_logs.txt || true
            exit 1
          fi

      - name: HTTPS smoke test (curl -k)
        id: smoke
        working-directory: docker
        run: |
          set -e
          RESULT=1
          for i in {1..20}; do
            if curl -k --silent --show-error --fail https://localhost:443/ -I; then
              echo "ok" > ./smoke_result.txt
              RESULT=0
              break
            fi
            echo "Waiting for HTTPS... ($i)"
            sleep 3
          done
          if [[ $RESULT -ne 0 ]]; then
            echo "fail" > ./smoke_result.txt
            docker compose logs --no-color > ./compose_logs.txt || true
            exit 1
          fi

      - name: Snapshot dashboard HTML (for Pages visualization)
        working-directory: docker
        run: |
          mkdir -p ../pages-site
          if curl -k --max-time 10 --silent --show-error https://localhost:443/ -o ../pages-site/dashboard_snapshot.html; then
            echo "Saved dashboard snapshot to pages-site/dashboard_snapshot.html"
          else
            echo "<!-- snapshot failed -->" > ../pages-site/dashboard_snapshot.html || true
          fi

      - name: Collect logs & create pages site
        working-directory: docker
        run: |
          # Prepare pages-site directory
          PAGES_DIR=../pages-site
          mkdir -p "$PAGES_DIR"

          STATUS=$(cat ./smoke_result.txt || echo "unknown")
          # Evaluate RUN_URL using GitHub expressions into a shell variable (safe for YAML)
          RUN_URL="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          LOG_SNIPPET="$(tail -n 200 compose_logs.txt 2>/dev/null || echo "No logs available")"

          # Create index.html without using a heredoc to avoid YAML parsing issues.
          # Use printf with explicit lines so the workflow YAML validator doesn't choke on the literal HTML.
          printf '%s\n' \
            '<!doctype html>' \
            '<html>' \
            '  <head><meta charset="utf-8"><title>SELKS Docker Compose smoke test</title></head>' \
            '  <body>' \
            '    <h1>SELKS Docker Compose smoke test</h1>' \
            "    <p>Result: <strong>${STATUS}</strong></p>" \
            "    <p>Workflow run: <a href=\"${RUN_URL}\">Open run</a></p>" \
            '    <h2>Dashboard snapshot</h2>' \
            '    <p>If snapshot failed, the file may be empty or contain an error note.</p>' \
            '    <iframe src="dashboard_snapshot.html" style="width:100%;height:600px;border:1px solid #ccc;"></iframe>' \
            '    <h2>Compose logs (tail)</h2>' \
            '    <pre>' > "$PAGES_DIR/index.html"

          # Append escaped logs
          printf '%s\n' "$(printf '%s' "${LOG_SNIPPET}" | sed -e 's/&/\&amp;/g' -e 's/</\&lt;/g' -e 's/>/\&gt;/g')" >> "$PAGES_DIR/index.html"

          # Finish the HTML file
          printf '%s\n' \
            '</pre>' \
            '    <p>Full logs: <a href="compose_logs.txt">compose_logs.txt</a></p>' \
            '  </body>' \
            '</html>' >> "$PAGES_DIR/index.html"

          cp compose_logs.txt "$PAGES_DIR/compose_logs.txt" || true
          ls -la "$PAGES_DIR"

      - name: Upload Pages artifact
        # Use versions that do not depend on actions/upload-artifact@v3
        uses: actions/upload-pages-artifact@v3
        with:
          path: pages-site

      - name: Deploy to GitHub Pages
        uses: actions/deploy-pages@v2

      - name: Tear down compose stack
        if: always()
        working-directory: docker
        run: |
          docker compose down --volumes --remove-orphans || true
