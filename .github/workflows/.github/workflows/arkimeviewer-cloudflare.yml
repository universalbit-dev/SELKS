on:
  workflow_dispatch:
    inputs:
      action:
        description: 'build or pull the image (build|pull)'
        required: false
        default: 'pull'
      image_tag:
        description: 'Image tag to use (if pulling) or tag to build'
        required: false
        default: 'snyk-fix-512a575e2bccee962042801ef03bb3d2'
      host_port:
        description: 'Host port to expose (host -> container)'
        required: false
        default: '8443'
      container_port:
        description: 'Container port to expose'
        required: false
        default: '443'
      container_name:
        description: 'Container name to use'
        required: false
        default: 'arkimeviewer'
permissions:
  contents: read
  packages: read

jobs:
  run-with-cloudflared:
    name: Pull/Build image, run container, start Cloudflare Tunnel
    runs-on: ubuntu-latest
    outputs:
      public_url: ${{ steps.publish.outputs.public_url }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Prepare variables
        run: |
          set -euo pipefail
          echo "IMAGE=ghcr.io/universalbit-dev/arkimeviewer:${{ inputs.image_tag }}" >> $GITHUB_ENV
          echo "CONTAINER_NAME=${{ inputs.container_name }}" >> $GITHUB_ENV
          echo "HOST_PORT=${{ inputs.host_port }}" >> $GITHUB_ENV
          echo "CONTAINER_PORT=${{ inputs.container_port }}" >> $GITHUB_ENV
          echo "ACTION=${{ inputs.action }}" >> $GITHUB_ENV
          # Required Cloudflare-related inputs are provided via repository secrets:
          # CF_TUNNEL_NAME (string) and CF_TUNNEL_HOSTNAME (hostname mapped to the tunnel)
          echo "CF_TUNNEL_NAME=${{ secrets.CF_TUNNEL_NAME }}" >> $GITHUB_ENV
          echo "CF_TUNNEL_HOSTNAME=${{ secrets.CF_TUNNEL_HOSTNAME }}" >> $GITHUB_ENV

      - name: Build image (if requested)
        if: ${{ env.ACTION == 'build' }}
        run: |
          set -euo pipefail
          echo "Building ${IMAGE}..."
          docker build -t "${IMAGE}" .

      - name: Pull image (if requested)
        if: ${{ env.ACTION != 'build' }}
        run: |
          set -euo pipefail
          echo "Pulling ${IMAGE}..."
          docker pull "${IMAGE}"

      - name: Stop and remove existing container (if present)
        run: |
          set -euo pipefail
          if docker ps -a --format '{{.Names}}' | grep -x "${CONTAINER_NAME}" >/dev/null 2>&1; then
            echo "Removing existing container ${CONTAINER_NAME}..."
            docker rm -f "${CONTAINER_NAME}" || true
          else
            echo "No existing container ${CONTAINER_NAME} found."
          fi

      - name: Start container
        run: |
          set -euo pipefail
          echo "Starting container ${CONTAINER_NAME} (host ${HOST_PORT} -> cont ${CONTAINER_PORT})..."
          docker run -d \
            --name "${CONTAINER_NAME}" \
            -p "${HOST_PORT}:${CONTAINER_PORT}" \
            --restart unless-stopped \
            "${IMAGE}"
          echo "Container started."

      - name: Install cloudflared
        run: |
          set -euo pipefail
          # Download latest cloudflared binary (Linux amd64)
          CLOUDFLARED_TGZ="cloudflared-linux-amd64.tgz"
          curl -fsSL -o $CLOUDFLARED_TGZ "https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64.tgz"
          tar xzf $CLOUDFLARED_TGZ
          chmod +x ./cloudflared
          ./cloudflared --version

      - name: Write Cloudflare tunnel credentials (from secret)
        if: ${{ secrets.CF_TUNNEL_CREDENTIALS != '' }}
        env:
          CF_TUNNEL_CREDENTIALS: ${{ secrets.CF_TUNNEL_CREDENTIALS }}
        run: |
          set -euo pipefail
          # CF_TUNNEL_CREDENTIALS should be base64-encoded content of the credentials JSON file you obtained when creating the tunnel.
          if [ -z "${CF_TUNNEL_CREDENTIALS:-}" ]; then
            echo "CF_TUNNEL_CREDENTIALS secret is empty. Aborting."
            exit 1
          fi
          echo "$CF_TUNNEL_CREDENTIALS" | base64 --decode > /tmp/tunnel-creds.json
          ls -l /tmp/tunnel-creds.json
          echo "Wrote tunnel credentials to /tmp/tunnel-creds.json"

      - name: Run Cloudflare Tunnel (background)
        env:
          CF_TUNNEL_NAME: ${{ secrets.CF_TUNNEL_NAME }}
          CF_TUNNEL_HOSTNAME: ${{ secrets.CF_TUNNEL_HOSTNAME }}
          HOST_PORT: ${{ inputs.host_port }}
        run: |
          set -euo pipefail
          if [ -z "${CF_TUNNEL_NAME:-}" ] || [ -z "${CF_TUNNEL_HOSTNAME:-}" ]; then
            echo "CF_TUNNEL_NAME or CF_TUNNEL_HOSTNAME secret is not set. Aborting."
            exit 1
          fi
          # Start the tunnel pointing to the container's host port.
          # We provide the --url flag so cloudflared forwards incoming requests to the local port.
          echo "Starting cloudflared tunnel '${CF_TUNNEL_NAME}' forwarding to http://127.0.0.1:${HOST_PORT} ..."
          # Run cloudflared in background and redirect logs
          nohup ./cloudflared tunnel --credentials-file /tmp/tunnel-creds.json run "${CF_TUNNEL_NAME}" --url "http://127.0.0.1:${HOST_PORT}" > cloudflared.log 2>&1 &
          # Wait until the public hostname is reachable (with a timeout)
          echo "Waiting up to 60s for https://${CF_TUNNEL_HOSTNAME} to become reachable..."
          for i in $(seq 1 60); do
            if curl -sS --head --fail "https://${CF_TUNNEL_HOSTNAME}" >/dev/null 2>&1; then
              echo "Public hostname https://${CF_TUNNEL_HOSTNAME} is reachable."
              break
            fi
            sleep 1
          done
          # Dump a few cloudflared log lines for debugging
          echo "==== cloudflared logs ===="
          tail -n 200 cloudflared.log || true
          echo "=========================="

      - name: Publish public URL and show container status
        id: publish
        env:
          CF_TUNNEL_HOSTNAME: ${{ secrets.CF_TUNNEL_HOSTNAME }}
        run: |
          set -euo pipefail
          if [ -z "${CF_TUNNEL_HOSTNAME:-}" ]; then
            echo "public_url=" >> $GITHUB_OUTPUT
            exit 1
          fi
          PUBLIC_URL="https://${CF_TUNNEL_HOSTNAME}"
          echo "Public URL: ${PUBLIC_URL}"
          echo "public_url=${PUBLIC_URL}" >> $GITHUB_OUTPUT
          echo "Docker container status:"
          docker ps --filter "name=${CONTAINER_NAME}" --format "table {{.ID}}\t{{.Image}}\t{{.Ports}}\t{{.Status}}"
